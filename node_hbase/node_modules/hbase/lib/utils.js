// Generated by CoffeeScript 1.8.0
var crypto, utils;

crypto = require('crypto');

utils = {
  base64: {
    encode: function(data, to_encoding) {
      if (to_encoding === 'base64') {
        return data;
      }
      if (!Buffer.isBuffer(data)) {
        data = new Buffer(data, to_encoding || 'utf8');
      }
      return data.toString('base64');
    },
    decode: function(data, from_encoding) {
      if (from_encoding === 'base64') {
        return data;
      }
      data = new Buffer(data, 'base64');
      if (!from_encoding) {
        return data;
      }
      return data.toString(from_encoding);
    }
  },
  url: {

    /*
    Arguments:
    *   `table`
    *   `key`
    *   `columns`
    *   `start`
    *   `end`
    *   `params`
     */
    encode: function(args) {
      var columnPath, cs, k, newpath, ps, v, _ref, _ref1;
      if (!args.table) {
        throw new Error('Missing parameters "table"');
      }
      newpath = '/';
      newpath += encodeURIComponent(args.table);
      if (args.key) {
        newpath += '/';
        newpath += encodeURIComponent(args.key);
      }
      if (args.columns) {
        columnPath = void 0;
        if (Array.isArray(args.columns)) {
          columnPath = args.columns.map(function(column) {
            if (Array.isArray(column)) {
              return column.map(function(c) {
                return encodeURIComponent(c);
              }).join(':');
            } else {
              return encodeURIComponent(column);
            }
          }).join(',');
        } else if (typeof args.columns === 'object') {
          cs = [];
          _ref = args.columns;
          for (k in _ref) {
            v = _ref[k];
            cs.push("" + (encodeURIComponent(k)) + ":" + (encodeURIComponent(v)));
          }
          columnPath = cs.join(',');
        } else {
          columnPath = args.columns ? encodeURIComponent(args.columns) : '';
        }
        if (columnPath) {
          newpath += "/";
        }
        if (columnPath) {
          newpath += "" + columnPath;
        }
      }
      if (args.end) {
        newpath += '/';
        if (args.start) {
          newpath += encodeURIComponent(args.start);
          newpath += ',';
        }
        newpath += encodeURIComponent(args.end);
      }
      if (args.params) {
        newpath += '?';
        ps = [];
        _ref1 = args.params;
        for (k in _ref1) {
          v = _ref1[k];
          ps.push("" + (encodeURIComponent(k)) + "=" + (encodeURIComponent(v)));
        }
        newpath += ps.join(',');
      }
      return newpath;
    }
  },
  merge: function() {
    var clone, copy, from, i, inverse, name, options, src, target, to, _i;
    target = arguments[0];
    from = 1;
    to = arguments.length;
    if (typeof target === 'boolean') {
      inverse = !!target;
      target = arguments[1];
      from = 2;
    }
    if (typeof target !== "object" && typeof target !== 'function') {
      target = {};
    }
    for (i = _i = from; from <= to ? _i < to : _i > to; i = from <= to ? ++_i : --_i) {
      if ((options = arguments[i]) !== null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if ((copy != null) && typeof copy === 'object' && !Array.isArray(copy) && !(copy instanceof RegExp)) {
            clone = src && (src && typeof src === 'object' ? src : {});
            target[name] = utils.merge(false, clone, copy);
          } else if (copy !== void 0) {
            if (!(inverse && typeof target[name] !== 'undefined')) {
              target[name] = copy;
            }
          }
        }
      }
    }
    return target;
  }
};

module.exports = utils;
